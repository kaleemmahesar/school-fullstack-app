import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
</original_code>```

import React, { useMemo, useState } from 'react';
import { useSelector } from 'react-redux';
import { Link, useLocation } from 'react-router-dom';
import { FaUsers, FaMoneyBillWave, FaChalkboardTeacher, FaBook, FaGraduationCap, FaChartLine, FaPlus, FaSearch, FaDollarSign, FaChartPie, FaChartBar, FaFilter, FaPrint, FaDownload, FaCalendarAlt, FaChevronLeft, FaChevronRight } from 'react-icons/fa';
import PageHeader from './common/PageHeader';

// Mock subsidy data for when viewing subsidies
const mockSubsidies = [
  {
    id: 'sub-1',
    quarter: 'Q1',
    year: 2023,
    amount: 50000,
    date: '2023-03-15',
    status: 'received',
    description: 'Q1 NGO Subsidy'
  },
  {
    id: 'sub-2',
    quarter: 'Q2',
    year: 2023,
    amount: 50000,
    date: '2023-06-15',
    status: 'received',
    description: 'Q2 NGO Subsidy'
  },
  {
    id: 'sub-3',
    quarter: 'Q3',
    year: 2023,
    amount: 50000,
    date: '2023-09-15',
    status: 'received',
    description: 'Q3 NGO Subsidy'
  },
  {
    id: 'sub-4',
    quarter: 'Q4',
    year: 2023,
    amount: 50000,
    date: '2023-12-15',
    status: 'planned',
    description: 'Q4 NGO Subsidy'
  }
];

const Dashboard = ({ viewMode }) => {
  const location = useLocation();
  const students = useSelector(state => state.students.students);
  const expenses = useSelector(state => state.expenses.expenses);
  const staff = useSelector(state => state.staff.staff);
  const classes = useSelector(state => state.classes.classes);
  
  // State for recent activities table
  const [activityType, setActivityType] = useState('all');
  const [searchTerm, setSearchTerm] = useState('');
  const [dateRange, setDateRange] = useState({ start: '', end: '' });
  const [transactionType, setTransactionType] = useState('all');
  const [showPrintView, setShowPrintView] = useState(false);
  
  // State for quarter/year filter
  const [selectedQuarter, setSelectedQuarter] = useState('all');
  const [selectedYear, setSelectedYear] = useState('all');
  
  // Pagination state
  const [currentPage, setCurrentPage] = useState(1);
  const [itemsPerPage] = useState(10);

  // Get unique years and quarters from activities for the filters
  const availableYears = useMemo(() => {
    if (viewMode === 'subsidies') {
      const years = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.date) {
          const year = new Date(subsidy.date).getFullYear();
          if (year) {
            years.add(year);
          }
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    } else {
      const years = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const year = new Date(fee.date).getFullYear();
              if (year) {
                years.add(year);
              }
            }
          });
        }
      });
      return Array.from(years).sort((a, b) => b - a);
    }
  }, [students, viewMode]);

  // Get available quarters
  const availableQuarters = useMemo(() => {
    if (viewMode === 'subsidies') {
      const quarters = new Set();
      mockSubsidies.forEach(subsidy => {
        if (subsidy.quarter) {
          const quarterNumber = parseInt(subsidy.quarter.replace('Q', ''));
          if (quarterNumber >= 1 && quarterNumber <= 4) {
            quarters.add(quarterNumber);
          }
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    } else {
      const quarters = new Set();
      students.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory.forEach(fee => {
            if (fee.date) {
              const date = new Date(fee.date);
              const month = date.getMonth(); // 0-11
              const quarterNumber = Math.floor(month / 3) + 1; // 1-4
              if (quarterNumber >= 1 && quarterNumber <= 4) {
                quarters.add(quarterNumber);
              }
            }
          });
        }
      });
      return Array.from(quarters).sort((a, b) => a - b);
    }
  }, [students, viewMode]);

  // Filter data based on selected quarter and year
  const filteredData = useMemo(() => {
    // If no filter is applied, return all data
    if (selectedQuarter === 'all' && selectedYear === 'all') {
      if (viewMode === 'subsidies') {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredSubsidies: mockSubsidies };
      } else {
        return { filteredExpenses: expenses, filteredStaff: staff, filteredFees: students };
      }
    }
    
    if (viewMode === 'subsidies') {
      // Filter subsidies by quarter and year
      const filteredSubsidies = mockSubsidies.filter(subsidy => {
        // Check year filter
        if (selectedYear !== 'all' && subsidy.year !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all') {
          const subsidyQuarter = parseInt(subsidy.quarter.replace('Q', ''));
          if (subsidyQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
        }
        
        return true;
      });
      
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredSubsidies };
    } else {
      // Filter expenses by quarter and year
      const filteredExpenses = expenses.filter(expense => {
        if (!expense.date) return false;
        
        const expenseDate = new Date(expense.date);
        const expenseYear = expenseDate.getFullYear();
        const expenseMonth = expenseDate.getMonth(); // 0-11
        const expenseQuarter = Math.floor(expenseMonth / 3) + 1; // 1-4
        
        // Check year filter
        if (selectedYear !== 'all' && expenseYear !== parseInt(selectedYear)) {
          return false;
        }
        
        // Check quarter filter
        if (selectedQuarter !== 'all' && expenseQuarter !== parseInt(selectedQuarter)) {
          return false;
        }
        
        return true;
      });
      
      // Filter staff salary history by quarter and year
      const filteredStaff = staff.map(member => {
        if (!member.salaryHistory) return member;
        
        const filteredSalaryHistory = member.salaryHistory.filter(record => {
          if (!record.paymentDate) return false;
          
          const paymentDate = new Date(record.paymentDate);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...member,
          salaryHistory: filteredSalaryHistory
        };
      });
      
      // Filter student fees by quarter and year
      const filteredFees = students.map(student => {
        if (!student.feesHistory) return student;
        
        const filteredFeesHistory = student.feesHistory.filter(record => {
          if (!record.date) return false;
          
          const paymentDate = new Date(record.date);
          const paymentYear = paymentDate.getFullYear();
          const paymentMonth = paymentDate.getMonth(); // 0-11
          const paymentQuarter = Math.floor(paymentMonth / 3) + 1; // 1-4
          
          // Check year filter
          if (selectedYear !== 'all' && paymentYear !== parseInt(selectedYear)) {
            return false;
          }
          
          // Check quarter filter
          if (selectedQuarter !== 'all' && paymentQuarter !== parseInt(selectedQuarter)) {
            return false;
          }
          
          return true;
        });
        
        return {
          ...student,
          feesHistory: filteredFeesHistory
        };
      });
      
      return { filteredExpenses, filteredStaff, filteredFees };
    }
  }, [expenses, staff, students, selectedQuarter, selectedYear, viewMode]);

  // Calculate statistics using useMemo for performance
  const stats = useMemo(() => {
    // Use filtered data if filters are applied, otherwise use all data
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    
    // Total expenses
    const totalExpenses = filteredExpenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total staff salaries (including allowances)
    const totalStaffSalaries = filteredStaff.reduce((sum, member) => {
      const allowances = (member.allowances || []).reduce((allowanceSum, allowance) => {
        return allowanceSum + parseFloat(allowance.amount || 0);
      }, 0);
      return sum + parseFloat(member.salary || 0) + allowances;
    }, 0);
    
    // Other expenses (excluding staff salaries)
    const otherExpenses = filteredExpenses
      .filter(expense => expense.category !== 'Salary')
      .reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
    
    // Total students
    const totalStudents = students.length;

    if (viewMode === 'subsidies') {
      // Calculate total subsidies received based on filtered received subsidies
      const totalSubsidiesReceived = filteredSubsidies
        .filter(subsidy => subsidy.status === 'received')
        .reduce((sum, subsidy) => sum + parseFloat(subsidy.amount || 0), 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalSubsidiesReceived - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalSubsidiesReceived,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    } else {
      // Calculate total fees collected based on filtered paid fees
      const totalFeesCollected = filteredFees.reduce((sum, student) => {
        if (student.feesHistory) {
          return sum + student.feesHistory
            .filter(fee => fee.status === 'paid')
            .reduce((feeSum, fee) => feeSum + parseFloat(fee.amount || 0), 0);
        }
        return sum;
      }, 0);
      
      // Net profit/loss (income - expenses)
      const netProfit = totalFeesCollected - (totalStaffSalaries + otherExpenses);
      
      // Students by class - include all classes, even those without students
      const studentsByClass = {};
      // Initialize with all classes
      classes.forEach(classItem => {
        studentsByClass[classItem.name] = 0;
      });
      // Add student data
      students.forEach(student => {
        if (!studentsByClass[student.class]) {
          studentsByClass[student.class] = 0;
        }
        studentsByClass[student.class] += 1;
      });
      
      // Expenses by category
      const expensesByCategory = filteredExpenses.reduce((acc, expense) => {
        if (!acc[expense.category]) {
          acc[expense.category] = 0;
        }
        acc[expense.category] += parseFloat(expense.amount);
        return acc;
      }, {});
      
      // Staff by position
      const staffByPosition = filteredStaff.reduce((acc, member) => {
        if (!acc[member.position]) {
          acc[member.position] = 0;
        }
        acc[member.position] += 1;
        return acc;
      }, {});

      return {
        totalExpenses,
        totalStaffSalaries,
        otherExpenses,
        netProfit,
        totalStudents,
        totalFeesCollected,
        studentsByClass,
        expensesByCategory,
        staffByPosition,
        totalStaff: filteredStaff.length
      };
    }
  }, [students, filteredData, classes, selectedQuarter, selectedYear, viewMode]);

  // Generate recent activities data
  const recentActivities = useMemo(() => {
    const { filteredExpenses, filteredStaff, filteredFees, filteredSubsidies } = filteredData;
    const activities = [];
    
    // Add student admission activities
    students.forEach(student => {
      activities.push({
        id: `student-${student.id}`,
        type: 'Student Admission',
        description: `${student.firstName} ${student.lastName} admitted to ${student.class}`,
        date: student.admissionDate || new Date().toISOString(),
        category: 'Students',
        amount: 0 // No admission fees in NGO school
      });
    });
    
    if (viewMode === 'subsidies') {
      // Add subsidy activities based on filtered data (only received subsidies)
      filteredSubsidies.forEach(subsidy => {
        if (subsidy.status === 'received' && subsidy.date) {
          activities.push({
            id: `subsidy-${subsidy.id}`,
            type: 'Subsidy Received',
            description: `${subsidy.description} for ${subsidy.quarter} ${subsidy.year}`,
            date: subsidy.date,
            category: 'Income',
            amount: parseFloat(subsidy.amount)
          });
        }
      });
    } else {
      // Add fee collection activities based on filtered data (only paid fees)
      filteredFees.forEach(student => {
        if (student.feesHistory) {
          student.feesHistory
            .filter(fee => fee.status === 'paid' && fee.date)
            .forEach(fee => {
              activities.push({
                id: `fee-${student.id}-${fee.id}`,
                type: 'Fee Collection',
                description: `Fee collected for ${fee.month} from ${student.firstName} ${student.lastName}`,
                date: fee.date,
                category: 'Fees',
                amount: parseFloat(fee.amount)
              });
            });
        }
      });
    }
    
    // Add expense activities
    filteredExpenses.forEach(expense => {
      activities.push({
        id: `expense-${expense.id}`,
        type: 'Expense',
        description: `${expense.description}`,
        date: expense.date,
        category: 'Expenses',
        amount: -parseFloat(expense.amount)  // Make expenses negative as they are outflows
      });
    });
    
    // Add staff activities
    filteredStaff.forEach(member => {
      activities.push({
        id: `staff-${member.id}`,
        type: 'Staff',
        description: `${member.firstName} ${member.lastName} joined as ${member.position}`,
        date: member.dateOfJoining || new Date().toISOString(),
        category: 'Staff',
        amount: 0
      });
    });
    
    // Sort by date (newest first)
    return activities.sort((a, b) => new Date(b.date) - new Date(a.date));
  }, [students, filteredData, selectedQuarter, selectedYear, viewMode]);

  // Filter activities based on selected criteria
  const filteredActivities = useMemo(() => {
    let filtered = [...recentActivities]; // Create a copy to avoid mutation
    
    // Filter by search term
    if (searchTerm) {
      filtered = filtered.filter(activity => 
        activity.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.type.toLowerCase().includes(searchTerm.toLowerCase()) ||
        activity.category.toLowerCase().includes(searchTerm.toLowerCase())
      );
    }
    
    // Filter by transaction type (in/out)
    if (transactionType === 'in') {
      // Income: Fees/Subsidies and Student admissions (positive amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Income' && activity.amount > 0) ||
        (activity.category === 'Students')
      );
    } else if (transactionType === 'out') {
      // Expense: Only actual expenses (negative amounts)
      filtered = filtered.filter(activity => 
        (activity.category === 'Expenses' && activity.amount < 0) ||
        (activity.category === 'Fees' && activity.amount < 0)
      );
    }
    
    // Filter by date range for custom activity type
    if (activityType === 'custom' && dateRange.start && dateRange.end) {
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        // Set end date to end of day
        endDate.setHours(23, 59, 59, 999);
        return activityDate >= startDate && activityDate <= endDate;
      });
    }
    
    // For other activity types, filter by date
    const now = new Date();
    if (activityType === 'daily') {
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= today && activityDate < tomorrow;
      });
    } else if (activityType === 'monthly') {
      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
      const startOfNextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      
      filtered = filtered.filter(activity => {
        const activityDate = new Date(activity.date);
        return activityDate >= startOfMonth && activityDate < startOfNextMonth;
      });
    }
    // 'all' shows all activities, so no additional filtering needed
    
    return filtered;
  }, [recentActivities, activityType, searchTerm, dateRange, transactionType]);

  // Calculate totals for income and expenses based on filtered activities
  const calculateTotals = useMemo(() => {
    let totalIncome = 0;
    let totalExpense = 0;
    
    filteredActivities.forEach(activity => {
      if ((activity.category === 'Income' && activity.amount > 0) ||
          (activity.category === 'Students') ||
          (activity.category === 'Fees' && activity.amount > 0)) {
        totalIncome += Math.abs(activity.amount);
      } else if ((activity.category === 'Expenses' && activity.amount < 0) ||
                 (activity.category === 'Fees' && activity.amount < 0)) {
        totalExpense += Math.abs(activity.amount);  // Use absolute value for expense total
      }
    });
    
    return {
      income: totalIncome,
      expense: totalExpense,
      net: totalIncome - totalExpense
    };
  }, [filteredActivities]);

  const isActive = (path) => {
    return location.pathname === path;
  };

  // Export to CSV
  const exportToCSV = () => {
    const csvContent = [
      ['Activity Type', 'Description', 'Category', 'Date', 'Amount'],
      ...filteredActivities.map(activity => [
        activity.type,
        activity.description,
        activity.category,
        activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A', // MySQL format
        activity.amount
      ])
    ].map(row => row.join(',')).join('\n');
    
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.setAttribute('href', url);
    link.setAttribute('download', `activities-${activityType}.csv`);
    link.style.visibility = 'hidden';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  // Print report
  const printReport = () => {
    setShowPrintView(true);
    // Scroll to top to ensure print view is visible
    setTimeout(() => {
      window.scrollTo(0, 0);
      // Trigger print after a short delay to ensure rendering
      setTimeout(() => {
        window.print();
        // Hide print view after printing
        setTimeout(() => {
          setShowPrintView(false);
        }, 1000);
      }, 500);
    }, 100);
  };

  // Pagination functions
  const paginate = (pageNumber) => setCurrentPage(pageNumber);
  
  // Calculate pagination variables
  const indexOfLastItem = currentPage * itemsPerPage;
  const indexOfFirstItem = indexOfLastItem - itemsPerPage;
  const currentActivities = filteredActivities.slice(indexOfFirstItem, indexOfLastItem);
  const totalPages = Math.ceil(filteredActivities.length / itemsPerPage);

  return (
    <div className="min-h-screen bg-gray-50">
      <PageHeader 
        title="Dashboard" 
        subtitle="School overview and recent activities"
        actionButton={
          <div className="flex space-x-2">
            <button
              onClick={printReport}
              className="inline-flex items-center px-3 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
              <FaPrint className="mr-1" /> Print
            </button>
            <button
              onClick={exportToCSV}
              className="inline-flex items-center px-3 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
            >
              <FaDownload className="mr-1" /> Export CSV
            </button>
          </div>
        }
      />

      {/* Print Styles */}
      {showPrintView && (
        <style>{`
          @media print {
            body { 
              -webkit-print-color-adjust: exact; 
              print-color-adjust: exact; 
              font-family: Arial, sans-serif;
              font-size: 12px;
              margin: 0;
              padding: 0;
            }
            .no-print { 
              display: none !important; 
            }
            .print-section {
              position: static !important;
              inset: 0 !important;
              z-index: auto !important;
              overflow: visible !important;
              background: white !important;
              margin: 0 !important;
              padding: 0.5in !important;
            }
            .print-header {
              text-align: center;
              border-bottom: 2px solid #333;
              padding-bottom: 10px;
              margin-bottom: 20px;
            }
            .print-header h2 {
              font-size: 20px;
              font-weight: bold;
              color: #000;
              margin-bottom: 5px;
            }
            .print-header p {
              font-size: 14px;
              color: #333;
            }
            .bg-white {
              background-color: #fff;
            }
            .border {
              border: 1px solid #ddd;
            }
            .rounded-lg {
              border-radius: 0.5rem;
            }
            .p-4 {
              padding: 1rem;
            }
            .shadow-sm {
              box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            }
            .text-sm {
              font-size: 0.875rem;
              line-height: 1.25rem;
            }
            .text-2xl {
              font-size: 1.5rem;
              line-height: 2rem;
            }
            .font-medium {
              font-weight: 500;
            }
            .font-semibold {
              font-weight: 600;
            }
            .text-gray-600 {
              color: #4b5563;
            }
            .text-gray-900 {
              color: #111827;
            }
            .text-green-600 {
              color: #16a34a;
            }
            .text-red-600 {
              color: #dc2626;
            }
            .grid {
              display: grid;
            }
            .grid-cols-1 {
              grid-template-columns: repeat(1, minmax(0, 1fr));
            }
            .md\\:grid-cols-3 {
              grid-template-columns: repeat(3, minmax(0, 1fr));
            }
            .gap-4 {
              gap: 1rem;
            }
            .mb-6 {
              margin-bottom: 1.5rem;
            }
            .min-w-full {
              min-width: 100%;
            }
            .divide-y > :not([hidden]) ~ :not([hidden]) {
              border-top-width: 1px;
            }
            .divide-gray-200 > :not([hidden]) ~ :not([hidden]) {
              border-color: #e5e7eb;
            }
            .px-6 {
              padding-left: 1.5rem;
              padding-right: 1.5rem;
            }
            .py-4 {
              padding-top: 1rem;
              padding-bottom: 1rem;
            }
            .py-3 {
              padding-top: 0.75rem;
              padding-bottom: 0.75rem;
            }
            .text-left {
              text-align: left;
            }
            .text-xs {
              font-size: 0.75rem;
              line-height: 1rem;
            }
            .uppercase {
              text-transform: uppercase;
            }
            .tracking-wider {
              letter-spacing: 0.05em;
            }
            .bg-gray-50 {
              background-color: #f9fafb;
            }
            .whitespace-nowrap {
              white-space: nowrap;
            }
            table {
              page-break-inside: auto;
              width: 100%;
              border-collapse: collapse;
            }
            th, td {
              padding: 8px;
              text-align: left;
              border: 1px solid #333;
            }
            th {
              background-color: #f2f2f2;
              font-weight: bold;
            }
            tr {
              page-break-inside: avoid;
              page-break-after: auto;
            }
            thead {
              display: table-header-group;
            }
            tfoot {
              display: table-footer-group;
            }
            .max-w-6xl {
              max-width: 72rem;
            }
            .mx-auto {
              margin-left: auto;
              margin-right: auto;
            }
            .p-6 {
              padding: 1.5rem;
            }
          }
        `}</style>
      )}
      
      {/* Main Content */}
      <main className="max-w-7xl mx-auto py-6">
        {location.pathname === '/' && (
          <div className="space-y-6">
            <div className="flex flex-col md:flex-row md:items-center md:justify-between">
              <div className="mb-4 md:mb-0">
                <p className="text-sm text-gray-600 mt-1">
                  Currently viewing: <span className="font-semibold">{viewMode === 'fees' ? 'Fees' : 'Subsidies'}</span> data
                </p>
              </div>
              <div className="flex items-center space-x-2 no-print">
                {/* Show quarters dropdown only in subsidy view */}
                {viewMode === 'subsidies' && (
                  <div className="flex items-center">
                    <FaCalendarAlt className="text-gray-400 mr-2" />
                    <select
                      value={selectedQuarter}
                      onChange={(e) => setSelectedQuarter(e.target.value)}
                      className="block w-full pl-3 pr-10 py-1 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm"
                    >
                      <option value="all">All Quarters</option>
                      <option value="1">Q1</option>
                      <option value="2">Q2</option>
                      <option value="3">Q3</option>
                      <option value="4">Q4</option>
                    </select>
                  </div>
                )}
                {/* Show year dropdown only in subsidy view */}
                {viewMode === 'subsidies' && (
                  <div className="flex items-center">
                    <select
                      value={selectedYear}
                      onChange={(e) => setSelectedYear(e.target.value)}
                      className="block w-full pl-3 pr-10 py-1 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm"
                    >
                      <option value="all">All Years</option>
                      {availableYears.map(year => (
                        <option key={year} value={year}>{year}</option>
                      ))}
                    </select>
                  </div>
                )}
              </div>
            </div>

            {/* Stats Cards */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
              <div className="bg-white rounded-lg shadow p-6">
                <div className="flex items-center">
                  <div className="p-3 bg-blue-100 rounded-full">
                    <FaUsers className="h-6 w-6 text-blue-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-600">Total Students</p>
                    <p className="text-2xl font-semibold text-gray-900">{stats.totalStudents}</p>
                  </div>
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-6">
                <div className="flex items-center">
                  <div className="p-3 bg-green-100 rounded-full">
                    <FaDollarSign className="h-6 w-6 text-green-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-600">
                      {viewMode === 'fees' ? 'Fees Collected' : 'NGO Subsidies'}
                    </p>
                    <p className="text-2xl font-semibold text-gray-900">
                      Rs {viewMode === 'fees' ? Math.round(stats.totalFeesCollected || 0) : Math.round(stats.totalSubsidiesReceived || 0)}
                    </p>
                  </div>
                </div>
              </div>
              
              <div className="bg-white rounded-lg shadow p-6">
                <div className="flex items-center">
                  <div className="p-3 bg-amber-100 rounded-full">
                    <FaMoneyBillWave className="h-6 w-6 text-amber-600" />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-600">Total Expenses</p>
                    <p className="text-2xl font-semibold text-gray-900">Rs {Math.round(stats.totalExpenses)}</p>
                  </div>
                </div>
              </div>
              
              <div className={`bg-white rounded-lg shadow p-6 ${stats.netProfit >= 0 ? 'border-t-4 border-green-500' : 'border-t-4 border-red-500'}`}>
                <div className="flex items-center">
                  <div className={`p-3 rounded-full ${stats.netProfit >= 0 ? 'bg-green-100' : 'bg-red-100'}`}>
                    <FaChartBar className={`h-6 w-6 ${stats.netProfit >= 0 ? 'text-green-600' : 'text-red-600'}`} />
                  </div>
                  <div className="ml-4">
                    <p className="text-sm font-medium text-gray-600">Net Profit/Loss</p>
                    <p className={`text-2xl font-semibold ${stats.netProfit >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                      Rs {Math.round(Math.abs(stats.netProfit))} {stats.netProfit >= 0 ? '' : '(Loss)'}
                    </p>
                  </div>
                </div>
              </div>
            </div>

            {/* Charts Section */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              {/* Students by Class */}
              <div className="bg-white rounded-lg shadow p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-lg font-semibold text-gray-800">Students by Class</h3>
                  <FaChartPie className="text-gray-400" />
                </div>
                <div className="space-y-3">
                  {classes.map((classItem) => {
                    const count = stats.studentsByClass[classItem.name] || 0;
                    return (
                      <div key={classItem.name} className="flex items-center">
                        <div className="w-32 text-sm text-gray-600">{classItem.name}</div>
                        <div className="flex-1 ml-2">
                          <div className="flex items-center">
                            <div className="w-full bg-gray-200 rounded-full h-2">
                              <div 
                                className="bg-blue-600 h-2 rounded-full" 
                                style={{ width: `${stats.totalStudents > 0 ? (count / stats.totalStudents) * 100 : 0}%` }}
                              ></div>
                            </div>
                            <div className="ml-2 text-sm font-medium text-gray-700 w-10">{count}</div>
                          </div>
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>

              {/* Income Utilization */}
              <div className="bg-white rounded-lg shadow p-6">
                <div className="flex items-center justify-between mb-4">
                  <h3 className="text-lg font-semibold text-gray-800">
                    {viewMode === 'fees' ? 'Fee Utilization' : 'Subsidy Utilization'}
                  </h3>
                  <FaChartBar className="text-gray-400" />
                </div>
                <div className="space-y-4">
                  <div className="flex items-center">
                    <div className="w-32 text-sm text-gray-600">Staff Salaries</div>
                    <div className="flex-1 ml-2">
                      <div className="flex items-center">
                        <div className="w-full bg-gray-200 rounded-full h-2">
                          <div 
                            className="bg-red-600 h-2 rounded-full" 
                            style={{ width: `${(stats.totalFeesCollected || stats.totalSubsidiesReceived) > 0 ? (stats.totalStaffSalaries / (stats.totalFeesCollected || stats.totalSubsidiesReceived)) * 100 : 0}%` }}
                          ></div>
                        </div>
                        <div className="ml-2 text-sm font-medium text-gray-700 w-24">
                          Rs {Math.round(stats.totalStaffSalaries)}
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <div className="flex items-center">
                    <div className="w-32 text-sm text-gray-600">Other Expenses</div>
                    <div className="flex-1 ml-2">
                      <div className="flex items-center">
                        <div className="w-full bg-gray-200 rounded-full h-2">
                          <div 
                            className="bg-amber-600 h-2 rounded-full" 
                            style={{ width: `${(stats.totalFeesCollected || stats.totalSubsidiesReceived) > 0 ? (stats.otherExpenses / (stats.totalFeesCollected || stats.totalSubsidiesReceived)) * 100 : 0}%` }}
                          ></div>
                        </div>
                        <div className="ml-2 text-sm font-medium text-gray-700 w-24">
                          Rs {Math.round(stats.otherExpenses)}
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <div className="flex items-center">
                    <div className="w-32 text-sm text-gray-600">Remaining</div>
                    <div className="flex-1 ml-2">
                      <div className="flex items-center">
                        <div className="w-full bg-gray-200 rounded-full h-2">
                          <div 
                            className="bg-green-600 h-2 rounded-full" 
                            style={{ width: `${(stats.totalFeesCollected || stats.totalSubsidiesReceived) > 0 ? (((stats.totalFeesCollected || stats.totalSubsidiesReceived) - stats.totalStaffSalaries - stats.otherExpenses) / (stats.totalFeesCollected || stats.totalSubsidiesReceived)) * 100 : 0}%` }}
                          ></div>
                        </div>
                        <div className="ml-2 text-sm font-medium text-gray-700 w-24">
                          Rs {Math.round((stats.totalFeesCollected || stats.totalSubsidiesReceived) - stats.totalStaffSalaries - stats.otherExpenses)}
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="mt-4 pt-4 border-t border-gray-200">
                  <div className="flex justify-between text-sm">
                    <span className="text-gray-600">Total {viewMode === 'fees' ? 'Fees' : 'Subsidies'}:</span>
                    <span className="font-medium">Rs {Math.round(stats.totalFeesCollected || stats.totalSubsidiesReceived)}</span>
                  </div>
                  <div className="flex justify-between text-sm">
                    <span className="text-gray-600">Total Expenses:</span>
                    <span className="font-medium">Rs {Math.round(stats.totalStaffSalaries + stats.otherExpenses)}</span>
                  </div>
                  <div className="flex justify-between text-sm font-semibold mt-1">
                    <span className={stats.netProfit >= 0 ? 'text-green-600' : 'text-red-600'}>
                      Net {stats.netProfit >= 0 ? 'Profit' : 'Loss'}:
                    </span>
                    <span className={stats.netProfit >= 0 ? 'text-green-600' : 'text-red-600'}>
                      Rs {Math.round(Math.abs(stats.netProfit))}
                    </span>
                  </div>
                  
                  {/* Filter info */}
                  {(selectedQuarter !== 'all' || selectedYear !== 'all') && (
                    <div className="mt-2 pt-2 border-t border-gray-100 text-xs text-gray-500">
                      Showing data for{' '}
                      {selectedQuarter !== 'all' ? `Q${selectedQuarter} ` : ''}
                      {selectedYear !== 'all' ? selectedYear : ''}
                    </div>
                  )}
                </div>
              </div>
            </div>

            {/* Subsidy Data Table - Only show in subsidy view */}
            {viewMode === 'subsidies' && (
              <div className="bg-white rounded-lg shadow p-6">
                <div className="flex flex-col md:flex-row md:items-center justify-between mb-6">
                  <h3 className="text-lg font-semibold text-gray-800 mb-4 md:mb-0">
                    NGO Subsidy Records
                  </h3>
                  
                  {/* Subsidy-specific filters */}
                  <div className="flex space-x-2 no-print">
                    <select
                      value={selectedQuarter}
                      onChange={(e) => setSelectedQuarter(e.target.value)}
                      className="block w-full pl-3 pr-10 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm"
                    >
                      <option value="all">All Quarters</option>
                      <option value="1">Q1</option>
                      <option value="2">Q2</option>
                      <option value="3">Q3</option>
                      <option value="4">Q4</option>
                    </select>
                    
                    {/* Year dropdown is not needed for subsidy view */}
                  </div>
                </div>
                
                {/* Subsidy Table */}
                <div className="overflow-x-auto">
                  <table className="min-w-full divide-y divide-gray-200">
                    <thead className="bg-gray-50">
                      <tr>
                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Quarter</th>
                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Year</th>
                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
                        <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th>
                      </tr>
                    </thead>
                    <tbody className="bg-white divide-y divide-gray-200">
                      {filteredData.filteredSubsidies && filteredData.filteredSubsidies.length > 0 ? (
                        [...filteredData.filteredSubsidies]
                          .sort((a, b) => new Date(b.date) - new Date(a.date)) // Sort by date descending
                          .map((subsidy) => (
                          <tr key={subsidy.id} className="hover:bg-gray-50">
                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{subsidy.quarter}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{subsidy.year}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">Rs {subsidy.amount.toLocaleString()}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                              {subsidy.date ? new Date(subsidy.date).toISOString().split('T')[0] : 'N/A'}
                            </td>
                            <td className="px-6 py-4 whitespace-nowrap">
                              <span className={`inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium ${
                                subsidy.status === 'received' 
                                  ? 'bg-green-100 text-green-800' 
                                  : 'bg-yellow-100 text-yellow-800'
                              }`}>
                                {subsidy.status === 'received' ? 'Received' : 'Planned'}
                              </span>
                            </td>
                            <td className="px-6 py-4 text-sm text-gray-500">{subsidy.description}</td>
                          </tr>
                        ))
                      ) : (
                        <tr>
                          <td colSpan="6" className="px-6 py-4 text-center text-sm text-gray-500">
                            No subsidy records found
                          </td>
                        </tr>
                      )}
                    </tbody>
                  </table>
                </div>
                
                {/* Subsidy Summary Stats */}
                <div className="mt-6 pt-6 border-t border-gray-200">
                  <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                    <div className="bg-blue-50 rounded-lg p-4">
                      <div className="text-sm font-medium text-blue-800">Total Subsidies</div>
                      <div className="text-2xl font-semibold text-blue-900">
                        {filteredData.filteredSubsidies ? filteredData.filteredSubsidies.length : 0}
                      </div>
                    </div>
                    <div className="bg-green-50 rounded-lg p-4">
                      <div className="text-sm font-medium text-green-800">Received</div>
                      <div className="text-2xl font-semibold text-green-900">
                        {filteredData.filteredSubsidies 
                          ? filteredData.filteredSubsidies.filter(s => s.status === 'received').length 
                          : 0}
                      </div>
                    </div>
                    <div className="bg-yellow-50 rounded-lg p-4">
                      <div className="text-sm font-medium text-yellow-800">Planned</div>
                      <div className="text-2xl font-semibold text-yellow-900">
                        {filteredData.filteredSubsidies 
                          ? filteredData.filteredSubsidies.filter(s => s.status === 'planned').length 
                          : 0}
                      </div>
                    </div>
                    <div className="bg-emerald-50 rounded-lg p-4">
                      <div className="text-sm font-medium text-emerald-800">Total Amount</div>
                      <div className="text-2xl font-semibold text-emerald-900">
                        Rs {filteredData.filteredSubsidies 
                          ? filteredData.filteredSubsidies
                              .reduce((sum, subsidy) => sum + (subsidy.status === 'received' ? subsidy.amount : 0), 0)
                              .toLocaleString()
                          : 0}
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Recent Activities Table with Filters and Report Generation */}
            <div className={`bg-white rounded-lg shadow p-6 ${showPrintView ? 'print-section' : ''}`}>
              {/* Print Header */}
              {showPrintView && (
                <div className="print-header">
                  <h1>SCHOOL MANAGEMENT SYSTEM</h1>
                  <p>Recent Activities Report</p>
                  <p>Generated on {new Date().toISOString().split('T')[0]}</p>
                  {(selectedQuarter !== 'all' || selectedYear !== 'all') && (
                    <p className="text-sm">
                      Filtered for {selectedQuarter !== 'all' ? `Q${selectedQuarter} ` : ''}
                      {selectedYear !== 'all' ? selectedYear : ''}
                    </p>
                  )}
                </div>
              )}
              
              <div className="flex flex-col md:flex-row md:items-center justify-between mb-6">
                <h3 className={`text-lg font-semibold text-gray-800 mb-4 md:mb-0 ${showPrintView ? 'print-header' : ''}`}>
                  Recent Activities ({viewMode === 'fees' ? 'Fees' : 'Subsidies'} View)
                </h3>
                
                {/* Action Buttons */}
                <div className="flex flex-col sm:flex-row gap-2 no-print w-full md:w-auto">
                  <div className="relative flex-grow max-w-md md:max-w-xs">
                    <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                      <FaSearch className="text-gray-400" />
                    </div>
                    <input
                      type="text"
                      placeholder="Search activities..."
                      className="block w-full pl-10 pr-3 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm"
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                    />
                  </div>
                  
                  <div className="flex gap-2">
                    <select
                      value={activityType}
                      onChange={(e) => {
                        setActivityType(e.target.value);
                        // Reset date range when changing activity type
                        if (e.target.value !== 'custom') {
                          setDateRange({ start: '', end: '' });
                        }
                      }}
                      className="block w-full pl-3 pr-10 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm"
                    >
                      <option value="all">All Activities</option>
                      <option value="daily">Today</option>
                      <option value="monthly">This Month</option>
                      <option value="custom">Custom Range</option>
                    </select>
                    
                    <select
                      value={transactionType}
                      onChange={(e) => setTransactionType(e.target.value)}
                      className="block w-full pl-3 pr-10 py-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500 text-sm"
                    >
                      <option value="all">All Transactions</option>
                      <option value="in">Income</option>
                      <option value="out">Expenses</option>
                    </select>
                    
                    <button
                      onClick={printReport}
                      className="inline-flex items-center px-3 py-2 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                    >
                      <FaPrint className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              </div>
              
              {/* Custom Date Range Picker */}
              {activityType === 'custom' && (
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6 no-print">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
                    <input
                      type="date"
                      value={dateRange.start}
                      onChange={(e) => setDateRange({...dateRange, start: e.target.value})}
                      className="block w-full border border-gray-300 rounded-md shadow-sm p-2 text-sm"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 mb-1">End Date</label>
                    <input
                      type="date"
                      value={dateRange.end}
                      onChange={(e) => setDateRange({...dateRange, end: e.target.value})}
                      className="block w-full border border-gray-300 rounded-md shadow-sm p-2 text-sm"
                    />
                  </div>
                </div>
              )}
              
              {/* Activities Table */}
              <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200">
                  <thead className="bg-gray-50">
                    <tr>
                      <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Activity</th>
                      <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th>
                      <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Category</th>
                      <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
                      <th scope="col" className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                    </tr>
                  </thead>
                  <tbody className="bg-white divide-y divide-gray-200">
                    {currentActivities.length > 0 ? (
                      currentActivities.map((activity) => (
                        <tr key={activity.id} className="hover:bg-gray-50">
                          <td className="px-4 py-2 whitespace-nowrap">
                            <div className="flex items-center">
                              <div className={`p-1.5 rounded-full ${
                                activity.category === 'Students' ? 'bg-blue-100 text-blue-600' :
                                activity.category === 'Fees' ? 'bg-green-100 text-green-600' :
                                activity.category === 'Income' ? 'bg-emerald-100 text-emerald-600' :
                                activity.category === 'Expenses' ? 'bg-red-100 text-red-600' :
                                'bg-purple-100 text-purple-600'
                              }`}>
                                {activity.category === 'Students' && <FaUsers className="h-3.5 w-3.5" />}
                                {activity.category === 'Fees' && <FaDollarSign className="h-3.5 w-3.5" />}
                                {activity.category === 'Income' && <FaChartLine className="h-3.5 w-3.5" />}
                                {activity.category === 'Expenses' && <FaMoneyBillWave className="h-3.5 w-3.5" />}
                                {activity.category === 'Staff' && <FaChalkboardTeacher className="h-3.5 w-3.5" />}
                              </div>
                              <div className="ml-2">
                                <div className="text-sm font-medium text-gray-900">{activity.type}</div>
                              </div>
                            </div>
                          </td>
                          <td className="px-4 py-2 text-sm text-gray-900">
                            {activity.description}
                          </td>
                          <td className="px-4 py-2 whitespace-nowrap text-sm text-gray-500">
                            {activity.category}
                          </td>
                          <td className="px-4 py-2 whitespace-nowrap text-sm text-gray-900">
                            {activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A'}
                          </td>
                          <td className="px-4 py-2 whitespace-nowrap text-sm font-medium">
                            {activity.amount >= 0 ? (
                              <span className="text-green-600">+Rs {activity.amount.toLocaleString()}</span>
                            ) : (
                              <span className="text-red-600">-Rs {Math.abs(activity.amount).toLocaleString()}</span>
                            )}
                          </td>
                        </tr>
                      ))
                    ) : (
                      <tr>
                        <td colSpan="5" className="px-4 py-4 text-center text-sm text-gray-500">
                          No activities found matching the current filters
                        </td>
                      </tr>
                    )}
                  </tbody>
                </table>
              </div>

              {/* Pagination */}
              <div className="flex items-center justify-between border-t border-gray-200 bg-white px-4 py-3 sm:px-6 no-print">
                <div className="flex flex-1 justify-between sm:hidden">
                  <button
                    onClick={() => paginate(currentPage - 1)}
                    disabled={currentPage === 1}
                    className="relative inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50"
                  >
                    Previous
                  </button>
                  <button
                    onClick={() => paginate(currentPage + 1)}
                    disabled={currentPage === totalPages}
                    className="relative ml-3 inline-flex items-center rounded-md border border-gray-300 bg-white px-4 py-2 text-sm font-medium text-gray-700 hover:bg-gray-50 disabled:opacity-50"
                  >
                    Next
                  </button>
                </div>
                <div className="hidden sm:flex sm:flex-1 sm:items-center sm:justify-between">
                  <div>
                    <p className="text-sm text-gray-700">
                      Showing <span className="font-medium">{indexOfFirstItem + 1}</span> to{' '}
                      <span className="font-medium">{Math.min(indexOfLastItem, filteredActivities.length)}</span> of{' '}
                      <span className="font-medium">{filteredActivities.length}</span> results
                    </p>
                  </div>
                  <div>
                    <nav className="isolate inline-flex -space-x-px rounded-md shadow-sm" aria-label="Pagination">
                      <button
                        onClick={() => paginate(currentPage - 1)}
                        disabled={currentPage === 1}
                        className="relative inline-flex items-center rounded-l-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600 disabled:opacity-50"
                      >
                        <span className="sr-only">Previous</span>
                        <FaChevronLeft className="h-5 w-5" aria-hidden="true" />
                      </button>
                      {[...Array(totalPages)].map((_, index) => {
                        const pageNum = index + 1;
                        return (
                          <button
                            key={pageNum}
                            onClick={() => paginate(pageNum)}
                            className={`relative inline-flex items-center px-4 py-2 text-sm font-semibold ${
                              currentPage === pageNum
                                ? 'z-10 bg-blue-600 text-white focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-blue-600'
                                : 'text-gray-900 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:outline-offset-0'
                            }`}
                          >
                            {pageNum}
                          </button>
                        );
                      })}
                      <button
                        onClick={() => paginate(currentPage + 1)}
                        disabled={currentPage === totalPages}
                        className="relative inline-flex items-center rounded-r-md px-2 py-2 text-gray-400 ring-1 ring-inset ring-gray-300 hover:bg-gray-50 focus:z-20 focus:outline-offset-0 disabled:opacity-50"
                      >
                        <span className="sr-only">Next</span>
                        <FaChevronRight className="h-5 w-5" aria-hidden="true" />
                      </button>
                    </nav>
                  </div>
                </div>
              </div>
              
              {/* Print View */}
              {showPrintView && (
                <div className="print-section mt-6">
                  <div className="print-header text-center mb-4">
                    <h2 className="text-xl font-bold">SCHOOL MANAGEMENT SYSTEM</h2>
                    <p>Recent Activities Report</p>
                    <p>Generated on {new Date().toISOString().split('T')[0]}</p>
                    {(selectedQuarter !== 'all' || selectedYear !== 'all') && (
                      <p className="text-sm">
                        Filtered for {selectedQuarter !== 'all' ? `Q${selectedQuarter} ` : ''}
                        {selectedYear !== 'all' ? selectedYear : ''}
                      </p>
                    )}
                  </div>
                  
                  {/* Summary Boxes */}
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                      <div className="text-sm font-medium text-gray-600">Total Activities</div>
                      <div className="text-2xl font-semibold text-gray-900">{filteredActivities.length}</div>
                    </div>
                    <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                      <div className="text-sm font-medium text-gray-600">Total Income</div>
                      <div className="text-2xl font-semibold text-green-600">Rs {calculateTotals.income.toLocaleString()}</div>
                    </div>
                    <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                      <div className="text-sm font-medium text-gray-600">Total Expenses</div>
                      <div className="text-2xl font-semibold text-red-600">Rs {calculateTotals.expense.toLocaleString()}</div>
                    </div>
                  </div>
                  
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                      <div className="text-sm font-medium text-gray-600">Net Position</div>
                      <div className={`text-2xl font-semibold ${calculateTotals.net >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                        Rs {Math.abs(calculateTotals.net).toLocaleString()} {calculateTotals.net >= 0 ? '' : '(Loss)'}
                      </div>
                    </div>
                    <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                      <div className="text-sm font-medium text-gray-600">Filter Type</div>
                      <div className="text-2xl font-semibold text-gray-900">
                        {activityType === 'all' ? 'All Activities' : 
                         activityType === 'daily' ? 'Today' : 
                         activityType === 'monthly' ? 'This Month' : 'Custom Range'}
                      </div>
                    </div>
                    <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                      <div className="text-sm font-medium text-gray-600">Transaction Type</div>
                      <div className="text-2xl font-semibold text-gray-900">
                        {transactionType === 'all' ? 'All Transactions' : 
                         transactionType === 'in' ? 'Income' : 'Expenses'}
                      </div>
                    </div>
                  </div>
                  
                  {/* Activities Table */}
                  <div className="bg-white rounded-lg shadow overflow-hidden">
                    <table className="min-w-full divide-y divide-gray-200">
                      <thead className="bg-gray-50">
                        <tr>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Activity</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Category</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
                          <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                        </tr>
                      </thead>
                      <tbody className="bg-white divide-y divide-gray-200">
                        {filteredActivities.map((activity) => (
                          <tr key={activity.id} className="hover:bg-gray-50">
                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{activity.type}</td>
                            <td className="px-6 py-4 text-sm text-gray-900">{activity.description}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{activity.category}</td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                              {activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A'}
                            </td>
                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                              {activity.amount >= 0 ? (
                                <span className="text-green-600">+Rs {activity.amount.toLocaleString()}</span>
                              ) : (
                                <span className="text-red-600">-Rs {Math.abs(activity.amount).toLocaleString()}</span>
                              )}
                            </td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                  
                  <div className="mt-4 text-center text-sm text-gray-500">
                    <p>School Management System - Activities Report</p>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      </main>
      
      {/* Print View - Outside main content to ensure visibility */}
      {showPrintView && (
        <div className="print-section fixed inset-0 bg-white z-50 overflow-auto">
          <div className="max-w-6xl mx-auto p-6">
            <div className="print-header text-center mb-6">
              <h2 className="text-2xl font-bold">SCHOOL MANAGEMENT SYSTEM</h2>
              <p className="text-lg">Recent Activities Report</p>
              <p className="text-base">Generated on {new Date().toISOString().split('T')[0]}</p>
              {(selectedQuarter !== 'all' || selectedYear !== 'all') && (
                <p className="text-sm mt-2">
                  Filtered for {selectedQuarter !== 'all' ? `Q${selectedQuarter} ` : ''}
                  {selectedYear !== 'all' ? selectedYear : ''}
                </p>
              )}
            </div>
            
            {/* Summary Boxes */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
              <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                <div className="text-sm font-medium text-gray-600">Total Activities</div>
                <div className="text-2xl font-semibold text-gray-900">{filteredActivities.length}</div>
              </div>
              <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                <div className="text-sm font-medium text-gray-600">Total Income</div>
                <div className="text-2xl font-semibold text-green-600">Rs {calculateTotals.income.toLocaleString()}</div>
              </div>
              <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                <div className="text-sm font-medium text-gray-600">Total Expenses</div>
                <div className="text-2xl font-semibold text-red-600">Rs {calculateTotals.expense.toLocaleString()}</div>
              </div>
            </div>
            
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
              <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                <div className="text-sm font-medium text-gray-600">Net Position</div>
                <div className={`text-2xl font-semibold ${calculateTotals.net >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                  Rs {Math.abs(calculateTotals.net).toLocaleString()} {calculateTotals.net >= 0 ? '' : '(Loss)'}
                </div>
              </div>
              <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                <div className="text-sm font-medium text-gray-600">Filter Type</div>
                <div className="text-2xl font-semibold text-gray-900">
                  {activityType === 'all' ? 'All Activities' : 
                   activityType === 'daily' ? 'Today' : 
                   activityType === 'monthly' ? 'This Month' : 'Custom Range'}
                </div>
              </div>
              <div className="bg-white border border-gray-300 rounded-lg p-4 shadow-sm">
                <div className="text-sm font-medium text-gray-600">Transaction Type</div>
                <div className="text-2xl font-semibold text-gray-900">
                  {transactionType === 'all' ? 'All Transactions' : 
                   transactionType === 'in' ? 'Income' : 'Expenses'}
                </div>
              </div>
            </div>
            
            {/* Activities Table */}
            <div className="bg-white rounded-lg shadow overflow-hidden mb-6">
              <table className="min-w-full divide-y divide-gray-200">
                <thead className="bg-gray-50">
                  <tr>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Activity</th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Description</th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Category</th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Date</th>
                    <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Amount</th>
                  </tr>
                </thead>
                <tbody className="bg-white divide-y divide-gray-200">
                  {filteredActivities.map((activity) => (
                    <tr key={activity.id} className="hover:bg-gray-50">
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{activity.type}</td>
                      <td className="px-6 py-4 text-sm text-gray-900">{activity.description}</td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500">{activity.category}</td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                        {activity.date ? new Date(activity.date).toISOString().split('T')[0] : 'N/A'}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                        {activity.amount >= 0 ? (
                          <span className="text-green-600">+Rs {activity.amount.toLocaleString()}</span>
                        ) : (
                          <span className="text-red-600">-Rs {Math.abs(activity.amount).toLocaleString()}</span>
                        )}
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
            
            <div className="mt-4 text-center text-sm text-gray-500">
              <p>School Management System - Activities Report</p>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default Dashboard;